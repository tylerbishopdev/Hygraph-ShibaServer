export declare type Maybe<T> = T | null;
export declare type InputMaybe<T> = Maybe<T>;
export declare type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export declare type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export declare type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    JSON: any;
    DateTime: any;
};
export declare type IAssetConfig = {
    apiKey: Scalars['String'];
};
export declare type FilestackSecurityOptions = {
    __typename?: 'FilestackSecurityOptions';
    enabled: Scalars['Boolean'];
    auth?: Maybe<FilestackSecurityAuthOptions>;
    globalExpires: Scalars['String'];
    stageOverrides: Array<StageFilestackSecurityOptions>;
};
export declare type FilestackSecurityAuthOptions = {
    __typename?: 'FilestackSecurityAuthOptions';
    policy: Scalars['String'];
    signature: Scalars['String'];
};
export declare type StageFilestackSecurityOptions = {
    __typename?: 'StageFilestackSecurityOptions';
    stage: Stage;
    expires: Scalars['String'];
};
export declare type Filestack = IAssetConfig & {
    __typename?: 'Filestack';
    apiKey: Scalars['String'];
    path: Scalars['String'];
    bucket: Scalars['String'];
    isManagedBucket: Scalars['Boolean'];
    security: FilestackSecurityOptions;
};
export declare type ContentModel = {
    __typename?: 'ContentModel';
    models: Array<IModel>;
    model: IModel;
    components: Array<Component>;
    component: Component;
    assetModel: IModel;
    enumerations: Array<Enumeration>;
    enumeration: Enumeration;
    locales: Array<Locale>;
    unions: Array<Maybe<Union>>;
    stages: Array<Stage>;
};
export declare type ContentModelModelsArgs = {
    includeSystemModels?: InputMaybe<Scalars['Boolean']>;
};
export declare type ContentModelModelArgs = {
    id: Scalars['ID'];
};
export declare type ContentModelComponentsArgs = {
    includeSystemComponents?: InputMaybe<Scalars['Boolean']>;
};
export declare type ContentModelComponentArgs = {
    id: Scalars['ID'];
};
export declare type ContentModelEnumerationsArgs = {
    includeSystemEnumerations?: InputMaybe<Scalars['Boolean']>;
};
export declare type ContentModelEnumerationArgs = {
    id: Scalars['ID'];
};
export declare enum ContentViewType {
    BuiltIn = "BUILT_IN",
    Public = "PUBLIC"
}
export declare enum ColumnOrderByDir {
    Asc = "ASC",
    Desc = "DESC"
}
export declare type OrderBy = {
    __typename?: 'OrderBy';
    orderByField: IField;
    orderDir: ColumnOrderByDir;
};
export declare type ContentView = {
    __typename?: 'ContentView';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    name: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    model: IModel;
    type: ContentViewType;
    isSystem: Scalars['Boolean'];
    orderBy?: Maybe<OrderBy>;
    columns: Array<ContentViewColumn>;
    viewGroup: ViewGroup;
    position?: Maybe<Scalars['Int']>;
    filters: Scalars['JSON'];
};
export declare type ContentViewColumn = {
    __typename?: 'ContentViewColumn';
    id: Scalars['ID'];
    field: IField;
    isVisible: Scalars['Boolean'];
    width?: Maybe<Scalars['Int']>;
    position: Scalars['Int'];
};
export declare type ContentViewFilterInput = {
    skip?: InputMaybe<Scalars['Int']>;
    limit?: InputMaybe<Scalars['Int']>;
    search?: InputMaybe<Scalars['String']>;
};
export declare type Stats = {
    __typename?: 'Stats';
    time: Scalars['DateTime'];
    value: Scalars['Float'];
};
export declare type Metrics = {
    __typename?: 'Metrics';
    apiOperations: Array<Stats>;
    assetTraffic: Array<Stats>;
    assetTransformations: Array<Stats>;
};
export declare type MetricsApiOperationsArgs = {
    start: Scalars['DateTime'];
    end: Scalars['DateTime'];
    resolution: Scalars['Int'];
};
export declare type MetricsAssetTrafficArgs = {
    start: Scalars['DateTime'];
    end: Scalars['DateTime'];
};
export declare type MetricsAssetTransformationsArgs = {
    start: Scalars['DateTime'];
    end: Scalars['DateTime'];
};
export declare type PermanentAuthToken = {
    __typename?: 'PermanentAuthToken';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    name: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    token: Scalars['String'];
    defaults: PermanentAuthTokenDefaults;
    contentPermissions: Array<IContentPermission>;
    managementPermissions: Array<ManagementPermission>;
};
export declare type PermanentAuthTokenDefaults = {
    __typename?: 'PermanentAuthTokenDefaults';
    stage: Stage;
};
export declare type AppToken = {
    __typename?: 'AppToken';
    id: Scalars['ID'];
    app: App;
};
export declare type ManagementPermission = {
    __typename?: 'ManagementPermission';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    description?: Maybe<Scalars['String']>;
    action: PermissionAction;
};
export declare enum PermissionAction {
    ProjectClone = "PROJECT_CLONE",
    ProjectUpdate = "PROJECT_UPDATE",
    ProjectDelete = "PROJECT_DELETE",
    ManagePayment = "MANAGE_PAYMENT",
    PlaygroundUse = "PLAYGROUND_USE",
    AuditLogsRead = "AUDIT_LOGS_READ",
    ViewTeamMemberSettings = "VIEW_TEAM_MEMBER_SETTINGS",
    ViewRolePermissionSettings = "VIEW_ROLE_PERMISSION_SETTINGS",
    ViewSchema = "VIEW_SCHEMA",
    EnvironmentCreate = "ENVIRONMENT_CREATE",
    EnvironmentRead = "ENVIRONMENT_READ",
    EnvironmentUpdate = "ENVIRONMENT_UPDATE",
    EnvironmentDelete = "ENVIRONMENT_DELETE",
    EnvironmentPromote = "ENVIRONMENT_PROMOTE",
    ModelCreate = "MODEL_CREATE",
    ModelRead = "MODEL_READ",
    ModelUpdate = "MODEL_UPDATE",
    ModelDelete = "MODEL_DELETE",
    ComponentCreate = "COMPONENT_CREATE",
    ComponentRead = "COMPONENT_READ",
    ComponentUpdate = "COMPONENT_UPDATE",
    ComponentDelete = "COMPONENT_DELETE",
    LocaleCreate = "LOCALE_CREATE",
    LocaleRead = "LOCALE_READ",
    LocaleUpdate = "LOCALE_UPDATE",
    LocaleDelete = "LOCALE_DELETE",
    StageCreate = "STAGE_CREATE",
    StageRead = "STAGE_READ",
    StageUpdate = "STAGE_UPDATE",
    StageDelete = "STAGE_DELETE",
    EnumerationCreate = "ENUMERATION_CREATE",
    EnumerationRead = "ENUMERATION_READ",
    EnumerationUpdate = "ENUMERATION_UPDATE",
    EnumerationDelete = "ENUMERATION_DELETE",
    FieldCreate = "FIELD_CREATE",
    FieldRead = "FIELD_READ",
    FieldUpdate = "FIELD_UPDATE",
    FieldDelete = "FIELD_DELETE",
    RemoteSourceCreate = "REMOTE_SOURCE_CREATE",
    RemoteSourceRead = "REMOTE_SOURCE_READ",
    RemoteSourceUpdate = "REMOTE_SOURCE_UPDATE",
    RemoteSourceDelete = "REMOTE_SOURCE_DELETE",
    PatCreate = "PAT_CREATE",
    PatRead = "PAT_READ",
    PatUpdate = "PAT_UPDATE",
    PatDelete = "PAT_DELETE",
    ContentviewCreate = "CONTENTVIEW_CREATE",
    ContentviewRead = "CONTENTVIEW_READ",
    ContentviewUpdate = "CONTENTVIEW_UPDATE",
    ContentviewSystemUpdate = "CONTENTVIEW_SYSTEM_UPDATE",
    ContentviewDelete = "CONTENTVIEW_DELETE",
    StorageBucketCreate = "STORAGE_BUCKET_CREATE",
    StorageBucketRead = "STORAGE_BUCKET_READ",
    StorageBucketUpdate = "STORAGE_BUCKET_UPDATE",
    StorageBucketDelete = "STORAGE_BUCKET_DELETE",
    RoleCreate = "ROLE_CREATE",
    RoleUpdate = "ROLE_UPDATE",
    RoleDelete = "ROLE_DELETE",
    WebhookCreate = "WEBHOOK_CREATE",
    WebhookRead = "WEBHOOK_READ",
    WebhookUpdate = "WEBHOOK_UPDATE",
    WebhookDelete = "WEBHOOK_DELETE",
    UserInvite = "USER_INVITE",
    UserAssignrole = "USER_ASSIGNROLE",
    UserRemove = "USER_REMOVE",
    ViewGroupCreate = "VIEW_GROUP_CREATE",
    ViewGroupRead = "VIEW_GROUP_READ",
    ViewGroupUpdate = "VIEW_GROUP_UPDATE",
    ViewGroupDelete = "VIEW_GROUP_DELETE",
    ContentCreate = "CONTENT_CREATE",
    ContentRead = "CONTENT_READ",
    ContentUpdate = "CONTENT_UPDATE",
    ContentDelete = "CONTENT_DELETE",
    ContentPublish = "CONTENT_PUBLISH",
    ContentUpdatePublished = "CONTENT_UPDATE_PUBLISHED",
    ContentPermissionCreate = "CONTENT_PERMISSION_CREATE",
    ContentPermissionRead = "CONTENT_PERMISSION_READ",
    ContentPermissionUpdate = "CONTENT_PERMISSION_UPDATE",
    ContentPermissionDelete = "CONTENT_PERMISSION_DELETE",
    IntegrationCreate = "INTEGRATION_CREATE",
    IntegrationRead = "INTEGRATION_READ",
    IntegrationUpdate = "INTEGRATION_UPDATE",
    IntegrationDelete = "INTEGRATION_DELETE",
    NetlifyTriggerBuild = "NETLIFY_TRIGGER_BUILD",
    ExtensionCreate = "EXTENSION_CREATE",
    ExtensionRead = "EXTENSION_READ",
    ExtensionUpdate = "EXTENSION_UPDATE",
    ExtensionDelete = "EXTENSION_DELETE",
    AppCreate = "APP_CREATE",
    AppUpdate = "APP_UPDATE",
    AppDelete = "APP_DELETE",
    AppInstallationCreate = "APP_INSTALLATION_CREATE",
    AppInstallationUpdate = "APP_INSTALLATION_UPDATE",
    AppInstallationDelete = "APP_INSTALLATION_DELETE"
}
export declare type MembersAggregate = {
    __typename?: 'MembersAggregate';
    count: Scalars['Int'];
};
export declare type PageInfo = {
    __typename?: 'PageInfo';
    hasNextPage: Scalars['Boolean'];
    hasPreviousPage: Scalars['Boolean'];
    pageSize: Scalars['Int'];
};
export declare type MembersConnection = {
    __typename?: 'MembersConnection';
    pageInfo: PageInfo;
    edges: Array<MemberEdge>;
    aggregate: MembersAggregate;
};
export declare type MemberEdge = {
    __typename?: 'MemberEdge';
    node: Member;
};
export declare type Progress = {
    __typename?: 'Progress';
    current: Scalars['Float'];
    max?: Maybe<Scalars['Float']>;
    percent?: Maybe<Scalars['Float']>;
    estimate?: Maybe<Scalars['Float']>;
};
export declare type EnvironmentLevelQuota = {
    __typename?: 'EnvironmentLevelQuota';
    locales: Progress;
    webhooks: Progress;
    models: Progress;
    stages: Progress;
    contentPermissions: Progress;
    remoteSources: Progress;
    components: Progress;
};
export declare type Role = {
    __typename?: 'Role';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    isDefault: Scalars['Boolean'];
    name: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    /**
     * Returns contentPermissions for a role.
     * Optionally filtered by environment.
     */
    contentPermissions: Array<IContentPermission>;
    managementPermissions: Array<ManagementPermission>;
    members: Array<Member>;
    membersConnection: MembersConnection;
};
export declare type RoleContentPermissionsArgs = {
    environmentId?: InputMaybe<Scalars['ID']>;
};
export declare type RoleMembersConnectionArgs = {
    skip?: Scalars['Int'];
    first?: Scalars['Int'];
};
export declare type ContentPermissionRoleTarget = {
    __typename?: 'ContentPermissionRoleTarget';
    role: Role;
    environment: Environment;
};
export declare type ContentPermissionPermanentAuthTokenTarget = {
    __typename?: 'ContentPermissionPermanentAuthTokenTarget';
    permanentAuthToken: PermanentAuthToken;
};
export declare type ContentPermissionAppTokenTarget = {
    __typename?: 'ContentPermissionAppTokenTarget';
    appInstallation?: Maybe<AppInstallation>;
};
export declare type ContentPermissionPublicTarget = {
    __typename?: 'ContentPermissionPublicTarget';
    environment: Environment;
};
export declare type ContentPermissionTarget = ContentPermissionRoleTarget | ContentPermissionPermanentAuthTokenTarget | ContentPermissionPublicTarget | ContentPermissionAppTokenTarget;
export declare type IContentPermission = {
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    enabled: Scalars['Boolean'];
    target: ContentPermissionTarget;
    model?: Maybe<IModel>;
};
export declare type ReadContentPermission = IContentPermission & {
    __typename?: 'ReadContentPermission';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    enabled: Scalars['Boolean'];
    target: ContentPermissionTarget;
    model?: Maybe<IModel>;
    locales?: Maybe<Array<Locale>>;
    stages?: Maybe<Array<Stage>>;
    condition?: Maybe<Scalars['String']>;
};
export declare type ReadVersionContentPermission = IContentPermission & {
    __typename?: 'ReadVersionContentPermission';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    enabled: Scalars['Boolean'];
    target: ContentPermissionTarget;
    model?: Maybe<IModel>;
};
export declare type CreateContentPermission = IContentPermission & {
    __typename?: 'CreateContentPermission';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    enabled: Scalars['Boolean'];
    target: ContentPermissionTarget;
    model?: Maybe<IModel>;
    locales?: Maybe<Array<Locale>>;
    condition?: Maybe<Scalars['String']>;
};
export declare type UpdateContentPermission = IContentPermission & {
    __typename?: 'UpdateContentPermission';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    enabled: Scalars['Boolean'];
    target: ContentPermissionTarget;
    model?: Maybe<IModel>;
    locales?: Maybe<Array<Locale>>;
    condition?: Maybe<Scalars['String']>;
};
export declare type DeleteContentPermission = IContentPermission & {
    __typename?: 'DeleteContentPermission';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    enabled: Scalars['Boolean'];
    target: ContentPermissionTarget;
    model?: Maybe<IModel>;
    locales?: Maybe<Array<Locale>>;
    condition?: Maybe<Scalars['String']>;
};
export declare type PublishContentPermission = IContentPermission & {
    __typename?: 'PublishContentPermission';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    enabled: Scalars['Boolean'];
    target: ContentPermissionTarget;
    model?: Maybe<IModel>;
    locales?: Maybe<Array<Locale>>;
    fromStages?: Maybe<Array<Stage>>;
    toStages?: Maybe<Array<Stage>>;
    condition?: Maybe<Scalars['String']>;
};
export declare type UnpublishContentPermission = IContentPermission & {
    __typename?: 'UnpublishContentPermission';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    enabled: Scalars['Boolean'];
    target: ContentPermissionTarget;
    model?: Maybe<IModel>;
    locales?: Maybe<Array<Locale>>;
    stages?: Maybe<Array<Stage>>;
    condition?: Maybe<Scalars['String']>;
};
export declare enum MigrationStatus {
    Queued = "QUEUED",
    Running = "RUNNING",
    Success = "SUCCESS",
    Timeout = "TIMEOUT",
    Failed = "FAILED"
}
export declare type Migration = {
    __typename?: 'Migration';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    finishedAt?: Maybe<Scalars['DateTime']>;
    /** @deprecated This will be replaced by a union of Member | PermanentAuthToken */
    triggeredBy?: Maybe<Member>;
    status: MigrationStatus;
    errors?: Maybe<Scalars['String']>;
    /** @deprecated Field no longer supported */
    operationType: MigrationOperationType;
    /** @deprecated Field no longer supported */
    resourceId?: Maybe<Scalars['ID']>;
    /** Name of the migration in case if was triggered via a named batch migration */
    name?: Maybe<Scalars['String']>;
};
export declare enum Remote_Graphql_Type {
    Scalar = "SCALAR",
    Object = "OBJECT",
    Interface = "INTERFACE",
    Union = "UNION",
    Enum = "ENUM",
    InputObject = "INPUT_OBJECT"
}
export declare type IRemoteSource = {
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    prefix: Scalars['String'];
    url: Scalars['String'];
    /**
     * Optional headers that will be sent to the remote source on every remote field. In case the remote field is using the same
     * Header Keys, the values will be overridden
     */
    headers?: Maybe<Scalars['JSON']>;
    type: RemoteSourceType;
    remoteTypeDefinitionsConnection: RemoteTypeDefinitionsConnection;
    debugEnabled: Scalars['Boolean'];
};
export declare type IRemoteSourceRemoteTypeDefinitionsConnectionArgs = {
    remoteGraphQLTypes?: InputMaybe<Array<Remote_Graphql_Type>>;
    isUserDefined?: InputMaybe<Scalars['Boolean']>;
    skip?: Scalars['Int'];
    first?: Scalars['Int'];
};
export declare type GraphQlRemoteSource = IRemoteSource & {
    __typename?: 'GraphQLRemoteSource';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    prefix: Scalars['String'];
    url: Scalars['String'];
    headers?: Maybe<Scalars['JSON']>;
    type: RemoteSourceType;
    remoteTypeDefinitionsConnection: RemoteTypeDefinitionsConnection;
    debugEnabled: Scalars['Boolean'];
    /**
     * Specific URL that will be used for introspection if the introspection is available on another url than the regular url.
     * Can be ignored if the introspection url is the same as the url of the remote source.
     */
    introspectionUrl?: Maybe<Scalars['String']>;
    /** HTTP Headers that will be used when sending the introspection only */
    introspectionHeaders?: Maybe<Scalars['JSON']>;
    /** HTTP method that will be used for introspection */
    introspectionMethod: GraphQlRemoteSourceIntrospectionMethod;
    schema: Scalars['String'];
};
export declare type GraphQlRemoteSourceRemoteTypeDefinitionsConnectionArgs = {
    remoteGraphQLTypes?: InputMaybe<Array<Remote_Graphql_Type>>;
    isUserDefined?: InputMaybe<Scalars['Boolean']>;
    skip?: Scalars['Int'];
    first?: Scalars['Int'];
};
export declare type RestRemoteSource = IRemoteSource & {
    __typename?: 'RESTRemoteSource';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    prefix: Scalars['String'];
    url: Scalars['String'];
    headers?: Maybe<Scalars['JSON']>;
    type: RemoteSourceType;
    remoteTypeDefinitionsConnection: RemoteTypeDefinitionsConnection;
    debugEnabled: Scalars['Boolean'];
};
export declare type RestRemoteSourceRemoteTypeDefinitionsConnectionArgs = {
    remoteGraphQLTypes?: InputMaybe<Array<Remote_Graphql_Type>>;
    isUserDefined?: InputMaybe<Scalars['Boolean']>;
    skip?: Scalars['Int'];
    first?: Scalars['Int'];
};
export declare type RemoteTypeDefinitionEdge = {
    __typename?: 'RemoteTypeDefinitionEdge';
    node: RemoteTypeDefinition;
};
export declare type RemoteTypeDefinitionsAggregate = {
    __typename?: 'RemoteTypeDefinitionsAggregate';
    count: Scalars['Int'];
};
export declare type RemoteTypeDefinitionsConnection = {
    __typename?: 'RemoteTypeDefinitionsConnection';
    pageInfo: PageInfo;
    edges: Array<RemoteTypeDefinitionEdge>;
    aggregate: RemoteTypeDefinitionsAggregate;
};
export declare type CommentingConfig = {
    __typename?: 'CommentingConfig';
    url: Scalars['String'];
    token: Scalars['String'];
    userKey: Scalars['String'];
};
export declare type Environment = {
    __typename?: 'Environment';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    name: Scalars['String'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    endpoint: Scalars['String'];
    deliveryUrl?: Maybe<Scalars['String']>;
    assetConfig: IAssetConfig;
    metrics: Metrics;
    webhook: Webhook;
    webhooks: Array<Webhook>;
    permanentAuthTokens: Array<PermanentAuthToken>;
    authToken: Scalars['String'];
    contentView: ContentView;
    contentViews: Array<ContentView>;
    viewGroups: Array<ViewGroup>;
    contentModel: ContentModel;
    remoteSources: Array<IRemoteSource>;
    remoteSource: IRemoteSource;
    /** @deprecated Revisions are no longer maintained */
    revisionCount: Scalars['Int'];
    migrations: Array<Migration>;
    migration: Migration;
    runningMigration?: Maybe<Migration>;
    publicContentAPI: PublicContentApi;
    isCloning?: Maybe<Scalars['Boolean']>;
    quotas: EnvironmentLevelQuota;
    integrations: Array<IIntegration>;
    integration: IIntegration;
    extensions: Array<IExtension>;
    extension: IExtension;
    appInstallations: Array<AppInstallation>;
    appInstallation: AppInstallation;
    diff: DiffEnvironmentPayload;
    commentingConfig?: Maybe<CommentingConfig>;
};
export declare type EnvironmentWebhookArgs = {
    id: Scalars['ID'];
};
export declare type EnvironmentContentViewArgs = {
    id: Scalars['ID'];
};
export declare type EnvironmentContentViewsArgs = {
    includeSystemModels?: InputMaybe<Scalars['Boolean']>;
    filter?: InputMaybe<ContentViewFilterInput>;
};
export declare type EnvironmentRemoteSourceArgs = {
    prefix: Scalars['String'];
};
export declare type EnvironmentMigrationArgs = {
    id?: InputMaybe<Scalars['ID']>;
    name?: InputMaybe<Scalars['String']>;
};
export declare type EnvironmentIntegrationArgs = {
    id: Scalars['ID'];
};
export declare type EnvironmentExtensionArgs = {
    id: Scalars['ID'];
};
export declare type EnvironmentAppInstallationsArgs = {
    status?: InputMaybe<AppInstallationStatus>;
};
export declare type EnvironmentAppInstallationArgs = {
    appApiId: Scalars['String'];
};
export declare type EnvironmentDiffArgs = {
    environmentName: Scalars['String'];
};
export declare type PublicContentApiDefauts = {
    __typename?: 'PublicContentAPIDefauts';
    stage: Stage;
};
export declare type PublicContentApi = {
    __typename?: 'PublicContentAPI';
    defaults: PublicContentApiDefauts;
    contentPermissions: Array<IContentPermission>;
};
export declare type IIntegration = {
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    displayName?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
};
export declare type NetlifyIntegration = IIntegration & {
    __typename?: 'NetlifyIntegration';
    /** Integration ID */
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    /** Integration display name on GCMS */
    displayName?: Maybe<Scalars['String']>;
    /** Integration description on GCMS */
    description?: Maybe<Scalars['String']>;
    /** Configured sites for netlify integration */
    sites: Array<NetlifySite>;
    models: Array<IModel>;
};
export declare type GatsbyCloudIntegration = IIntegration & {
    __typename?: 'GatsbyCloudIntegration';
    /** Integration ID */
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    /** Integration display name on GCMS */
    displayName?: Maybe<Scalars['String']>;
    /** Integration description on GCMS */
    description?: Maybe<Scalars['String']>;
    /** URL to your site */
    siteURL: Scalars['String'];
    /** Prefix of your site */
    sitePrefix: Scalars['String'];
    /** URL to the preview of your site */
    previewURL: Scalars['String'];
    /** URL to the production deployment of your site */
    productionURL: Scalars['String'];
    /** URL to trigger a Deploy Build. This webhook will be triggered when publishing and unpublishing entries. */
    buildWebhookURL: Scalars['String'];
    /** URL to trigger a CMS Preview build */
    previewWebhookURL: Scalars['String'];
};
export declare type NetlifySite = {
    __typename?: 'NetlifySite';
    id: Scalars['String'];
    displayName: Scalars['String'];
    url: Scalars['String'];
    /** Contains information of the last time the build state was changing. */
    lastState?: Maybe<NetlifyState>;
};
export declare type NetlifyState = {
    __typename?: 'NetlifyState';
    /** Current state the site is in */
    buildState: NetlifyBuildState;
    /** Time when the build of the site was started */
    buildStartedAt?: Maybe<Scalars['DateTime']>;
    /** Time when the build of the site was prepared */
    buildPreparedAt?: Maybe<Scalars['DateTime']>;
    /** Time when the build of the site was finished */
    buildFinishedAt?: Maybe<Scalars['DateTime']>;
    /** Member in the project who triggered a build. If the build was triggered externally this will be null. */
    triggeredBy?: Maybe<NetlifyStateTriggeredBy>;
};
export declare type NetlifyStateTriggeredBy = PermanentAuthToken | Member;
export declare enum ColorPalette {
    Pink = "PINK",
    Purple = "PURPLE",
    Orange = "ORANGE",
    Red = "RED",
    Brown = "BROWN",
    Teal = "TEAL",
    Green = "GREEN",
    Yellow = "YELLOW"
}
export declare type Stage = {
    __typename?: 'Stage';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    apiId: Scalars['String'];
    color: Scalars['String'];
    colorPaletteId: ColorPalette;
    backgroundColor: Scalars['String'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    isSystem: Scalars['Boolean'];
    position: Scalars['Int'];
};
export declare type Profile = {
    __typename?: 'Profile';
    id: Scalars['ID'];
    email: Scalars['String'];
    name: Scalars['String'];
    picture?: Maybe<Scalars['String']>;
    role?: Maybe<Scalars['String']>;
    purpose?: Maybe<Scalars['String']>;
    companyName?: Maybe<Scalars['String']>;
    companySize?: Maybe<Scalars['String']>;
};
export declare type IUser = {
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    profile: Profile;
    preferences?: Maybe<Scalars['JSON']>;
};
export declare type Member = IUser & {
    __typename?: 'Member';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    profile: Profile;
    preferences?: Maybe<Scalars['JSON']>;
    roles: Array<Role>;
    isOwner: Scalars['Boolean'];
};
export declare enum ViewGroupType {
    Custom = "CUSTOM",
    System = "SYSTEM",
    UserCreated = "USER_CREATED"
}
export declare enum ViewGroupContentType {
    Default = "DEFAULT",
    Asset = "ASSET"
}
export declare type ViewGroup = {
    __typename?: 'ViewGroup';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    name: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    environment: Environment;
    type: ViewGroupType;
    contentType: ViewGroupContentType;
    position: Scalars['Int'];
    createdBy?: Maybe<Member>;
    contentViews: Array<ContentView>;
};
export declare type ViewGroupContentViewsArgs = {
    filter?: InputMaybe<ContentViewFilterInput>;
};
export declare type Webhook = {
    __typename?: 'Webhook';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    name: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    url: Scalars['String'];
    method: WebhookMethod;
    headers: Scalars['JSON'];
    isActive: Scalars['Boolean'];
    environment: Environment;
    /**
     * List of models on which the webhook will be triggered.
     * In case of any model, this array will be empty.
     */
    models: Array<IModel>;
    /**
     * List of stages on which the webhook will be triggered.
     * In case of any stage, this array will be empty.
     */
    stages: Array<Stage>;
    /** The type of trigger the webhook is registered */
    triggerType: WebhookTriggerType;
    /** When one of the actions happen, the webhook will be triggered */
    triggerActions: Array<WebhookTriggerAction>;
    /**
     * Defines wether the data of the changed data will be sent
     * in the webhook payload or not
     */
    includePayload: Scalars['Boolean'];
    hasSecretKey?: Maybe<Scalars['Boolean']>;
    logs: WebhookLogsPayload;
    log?: Maybe<WebhookLog>;
    triggerSources?: Maybe<Array<WebhookTriggerSource>>;
    createdBy?: Maybe<CreatedBy>;
    isSystem: Scalars['Boolean'];
};
export declare type WebhookLogsArgs = {
    where?: InputMaybe<WebhookLogsWhereInput>;
    limit?: InputMaybe<Scalars['Int']>;
    skip?: InputMaybe<Scalars['Int']>;
    after?: InputMaybe<Scalars['String']>;
    orderBy?: InputMaybe<WebhookLogOrderByInput>;
};
export declare type WebhookLogArgs = {
    id: Scalars['String'];
};
export declare enum WebhookTriggerSource {
    Pat = "PAT",
    Member = "MEMBER",
    Public = "PUBLIC"
}
export declare type WebhookLogsPayload = {
    __typename?: 'WebhookLogsPayload';
    total: Scalars['Int'];
    entries: Array<WebhookLog>;
};
export declare type WebhookLogsWhereInput = {
    action_eq?: InputMaybe<WebhookTriggerAction>;
    modelId_eq?: InputMaybe<Scalars['ID']>;
    status_eq?: InputMaybe<Scalars['Int']>;
    status_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
    status_gt?: InputMaybe<Scalars['Int']>;
    status_gte?: InputMaybe<Scalars['Int']>;
    status_lt?: InputMaybe<Scalars['Int']>;
    status_lte?: InputMaybe<Scalars['Int']>;
};
export declare enum WebhookLogOrderByInput {
    CalledAtAsc = "calledAt_ASC",
    CalledAtDesc = "calledAt_DESC"
}
export declare type WebhookLog = {
    __typename?: 'WebhookLog';
    id: Scalars['String'];
    requestPayload?: Maybe<Scalars['JSON']>;
    responsePayload?: Maybe<Scalars['String']>;
    responsePayloadSize?: Maybe<Scalars['Int']>;
    calledAt: Scalars['DateTime'];
    statusCode: Scalars['Int'];
    model?: Maybe<IModel>;
    triggerAction: WebhookTriggerAction;
    attempts: Scalars['Int'];
    duration: Scalars['Float'];
};
/** Defines the type of the trigger */
export declare enum WebhookTriggerType {
    ContentModel = "CONTENT_MODEL"
}
/**
 * Defines which operation will trigger the webhook.
 * Some operations rely on the type of stage. E.g. on a
 * publishing stage, the webhook will only be triggered for
 * PUBLISH and UNPUBLISH events. On other stages, only
 * CREATE, UPDATE and DELETE are triggering the webhook.
 */
export declare enum WebhookTriggerAction {
    Create = "CREATE",
    Update = "UPDATE",
    Delete = "DELETE",
    Publish = "PUBLISH",
    Unpublish = "UNPUBLISH"
}
export declare enum WebhookMethod {
    Get = "GET",
    Post = "POST",
    Put = "PUT",
    Delete = "DELETE"
}
export declare enum AvailableExtensionSrcType {
    Inline = "INLINE",
    Sdk = "SDK"
}
export declare enum AvailableExtensionPermissionAction {
    Input = "INPUT",
    Form = "FORM",
    Api = "API"
}
export declare enum ExtensionFieldType {
    Id = "ID",
    String = "STRING",
    Richtext = "RICHTEXT",
    Int = "INT",
    Float = "FLOAT",
    Boolean = "BOOLEAN",
    Json = "JSON",
    Datetime = "DATETIME",
    Date = "DATE",
    Location = "LOCATION",
    Color = "COLOR",
    Graphql = "GRAPHQL",
    Rest = "REST",
    Enumeration = "ENUMERATION",
    Relation = "RELATION",
    Asset = "ASSET",
    Union = "UNION"
}
export declare type ExtensionSrcType = {
    __typename?: 'ExtensionSrcType';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    description?: Maybe<Scalars['String']>;
    name: Scalars['String'];
    type: AvailableExtensionSrcType;
};
export declare type AvailableExtensionPermission = {
    __typename?: 'AvailableExtensionPermission';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    description?: Maybe<Scalars['String']>;
    name: AvailableExtensionPermissionAction;
};
export declare type IExtension = {
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    createdBy?: Maybe<Member>;
    updatedBy?: Maybe<Member>;
    name?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    apiId: Scalars['String'];
    /** The type indicating where the source for the extension will be obtained from */
    srcType: ExtensionSrcType;
    /** Location for the source if the source type is an external one */
    src: Scalars['String'];
    environment: Environment;
    config: Scalars['JSON'];
    isActive: Scalars['Boolean'];
    meta?: Maybe<Scalars['JSON']>;
    neededPermissions: Array<AvailableExtensionPermission>;
};
export declare type FieldExtension = IExtension & {
    __typename?: 'FieldExtension';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    createdBy?: Maybe<Member>;
    updatedBy?: Maybe<Member>;
    name?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    apiId: Scalars['String'];
    /** The type indicating where the source for the extension will be obtained from */
    srcType: ExtensionSrcType;
    /** Location for the source if the source type is an external one */
    src: Scalars['String'];
    environment: Environment;
    config: Scalars['JSON'];
    isActive: Scalars['Boolean'];
    meta?: Maybe<Scalars['JSON']>;
    neededPermissions: Array<AvailableExtensionPermission>;
    fieldType: ExtensionFieldType;
    hasFormRenderer: Scalars['Boolean'];
    hasListRenderer: Scalars['Boolean'];
    hasTableRenderer: Scalars['Boolean'];
    fields: Array<IField>;
};
export declare type SidebarExtension = IExtension & {
    __typename?: 'SidebarExtension';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    createdBy?: Maybe<Member>;
    updatedBy?: Maybe<Member>;
    name?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    apiId: Scalars['String'];
    /** The type indicating where the source for the extension will be obtained from */
    srcType: ExtensionSrcType;
    /** Location for the source if the source type is an external one */
    src: Scalars['String'];
    environment: Environment;
    config: Scalars['JSON'];
    isActive: Scalars['Boolean'];
    meta?: Maybe<Scalars['JSON']>;
    neededPermissions: Array<AvailableExtensionPermission>;
    sidebarElements: Array<ISidebarElement>;
};
export declare enum AppPublicationStatus {
    Private = "PRIVATE",
    Pending = "PENDING",
    Public = "PUBLIC"
}
export declare enum AppSchemaPermission {
    None = "NONE",
    Read = "READ",
    ReadWrite = "READ_WRITE"
}
export declare enum AppContentPermission {
    None = "NONE",
    Read = "READ",
    ReadWrite = "READ_WRITE"
}
export declare enum AppWebhooksPermission {
    None = "NONE",
    ReadWrite = "READ_WRITE"
}
export declare type AppPermissions = {
    __typename?: 'AppPermissions';
    SCHEMA: AppSchemaPermission;
    CONTENT: AppContentPermission;
    WEBHOOKS: AppWebhooksPermission;
};
export declare type IApp = {
    id: Scalars['ID'];
    author: Scalars['ID'];
    name: Scalars['String'];
    apiId: Scalars['String'];
    setupUrl: Scalars['String'];
    webhookUrl?: Maybe<Scalars['String']>;
    configurationUrl?: Maybe<Scalars['String']>;
    elements?: Maybe<Array<IAppElement>>;
    avatarUrl: Scalars['String'];
    description: Scalars['String'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    publicationStatus: AppPublicationStatus;
    permissions: AppPermissions;
};
export declare type App = IApp & {
    __typename?: 'App';
    id: Scalars['ID'];
    author: Scalars['ID'];
    name: Scalars['String'];
    apiId: Scalars['String'];
    setupUrl: Scalars['String'];
    webhookUrl?: Maybe<Scalars['String']>;
    configurationUrl?: Maybe<Scalars['String']>;
    elements?: Maybe<Array<IAppElement>>;
    avatarUrl: Scalars['String'];
    description: Scalars['String'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    publicationStatus: AppPublicationStatus;
    permissions: AppPermissions;
};
export declare enum AppElementType {
    Field = "field",
    FormSidebar = "formSidebar",
    Page = "page"
}
export declare type IAppElement = {
    id: Scalars['ID'];
    name: Scalars['String'];
    apiId: Scalars['String'];
    type: AppElementType;
    description?: Maybe<Scalars['String']>;
    config?: Maybe<Scalars['JSON']>;
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    src: Scalars['String'];
    app: App;
};
export declare enum FieldAppElementFeature {
    FieldRenderer = "FieldRenderer",
    ListRenderer = "ListRenderer",
    TableRenderer = "TableRenderer"
}
export declare type FieldAppElement = IAppElement & {
    __typename?: 'FieldAppElement';
    id: Scalars['ID'];
    name: Scalars['String'];
    apiId: Scalars['String'];
    type: AppElementType;
    description?: Maybe<Scalars['String']>;
    config?: Maybe<Scalars['JSON']>;
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    src: Scalars['String'];
    features: Array<FieldAppElementFeature>;
    fieldType: SimpleFieldType;
    app: App;
};
export declare type FormSidebarAppElement = IAppElement & {
    __typename?: 'FormSidebarAppElement';
    id: Scalars['ID'];
    name: Scalars['String'];
    apiId: Scalars['String'];
    type: AppElementType;
    description?: Maybe<Scalars['String']>;
    config?: Maybe<Scalars['JSON']>;
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    src: Scalars['String'];
    app: App;
};
export declare type PageAppElement = IAppElement & {
    __typename?: 'PageAppElement';
    id: Scalars['ID'];
    name: Scalars['String'];
    apiId: Scalars['String'];
    type: AppElementType;
    description?: Maybe<Scalars['String']>;
    config?: Maybe<Scalars['JSON']>;
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    src: Scalars['String'];
    app: App;
};
export declare enum AppInstallationStatus {
    Pending = "PENDING",
    Completed = "COMPLETED",
    Disabled = "DISABLED"
}
export declare type AppInstallation = {
    __typename?: 'AppInstallation';
    id: Scalars['ID'];
    environment: Environment;
    fields: Array<IField>;
    sidebarElements: Array<AppSidebarElement>;
    app: App;
    config: Scalars['JSON'];
    status: AppInstallationStatus;
    authToken: Scalars['String'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
};
export declare type EnumerationValue = {
    __typename?: 'EnumerationValue';
    id: Scalars['ID'];
    apiId: Scalars['String'];
    displayName: Scalars['String'];
};
export declare type Enumeration = {
    __typename?: 'Enumeration';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    environment: Environment;
    values: Array<EnumerationValue>;
    isSystem: Scalars['Boolean'];
    createdBy?: Maybe<CreatedBy>;
};
export declare type IRequireableField = {
    isRequired: Scalars['Boolean'];
};
export declare type IUniqueableField = {
    isUnique: Scalars['Boolean'];
};
export declare type ILocalizableField = {
    isLocalized: Scalars['Boolean'];
};
export declare type ITitleableField = {
    isTitle: Scalars['Boolean'];
};
export declare type FieldValidationFloatRange = {
    __typename?: 'FieldValidationFloatRange';
    min?: Maybe<Scalars['Float']>;
    max?: Maybe<Scalars['Float']>;
    errorMessage?: Maybe<Scalars['String']>;
};
export declare type FieldValidationRange = {
    __typename?: 'FieldValidationRange';
    min?: Maybe<Scalars['Int']>;
    max?: Maybe<Scalars['Int']>;
    errorMessage?: Maybe<Scalars['String']>;
};
export declare type FieldValidationRegEx = {
    __typename?: 'FieldValidationRegEx';
    regex?: Maybe<Scalars['String']>;
    flags?: Maybe<Array<Scalars['String']>>;
    errorMessage?: Maybe<Scalars['String']>;
};
export declare type StringFieldValidations = {
    __typename?: 'StringFieldValidations';
    characters?: Maybe<FieldValidationRange>;
    listItemCount?: Maybe<FieldValidationRange>;
    matches?: Maybe<FieldValidationRegEx>;
    notMatches?: Maybe<FieldValidationRegEx>;
};
export declare type IntFieldValidations = {
    __typename?: 'IntFieldValidations';
    range?: Maybe<FieldValidationRange>;
    listItemCount?: Maybe<FieldValidationRange>;
};
export declare type FloatFieldValidations = {
    __typename?: 'FloatFieldValidations';
    range?: Maybe<FieldValidationFloatRange>;
    listItemCount?: Maybe<FieldValidationRange>;
};
export declare type SimpleFieldValidations = StringFieldValidations | IntFieldValidations | FloatFieldValidations;
export declare type IField = {
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    isSystem: Scalars['Boolean'];
    isList: Scalars['Boolean'];
    position: Scalars['Int'];
    /** @deprecated Use visibility instead */
    isHidden: Scalars['Boolean'];
    visibility: VisibilityTypes;
    /**
     * This will throw a runtime error for fields that are on a component instead of model!
     * @deprecated Use parent instead
     */
    model: IModel;
    parent: IFieldParent;
    tableConfig: FieldConfig;
    formConfig: FieldConfig;
    extensions?: Maybe<Scalars['JSON']>;
    meta?: Maybe<Scalars['JSON']>;
    createdBy?: Maybe<CreatedBy>;
};
/** Field types */
export declare enum SimpleFieldType {
    Id = "ID",
    String = "STRING",
    Richtext = "RICHTEXT",
    Int = "INT",
    Float = "FLOAT",
    Boolean = "BOOLEAN",
    Json = "JSON",
    Datetime = "DATETIME",
    Date = "DATE",
    Location = "LOCATION",
    Color = "COLOR"
}
export declare enum RemoteFieldType {
    Graphql = "GRAPHQL",
    Rest = "REST"
}
export declare enum RemoteFieldApiMethod {
    Get = "GET",
    Post = "POST"
}
export declare enum GraphQlRemoteSourceIntrospectionMethod {
    Get = "GET",
    Post = "POST"
}
export declare enum EnumerableFieldType {
    Enumeration = "ENUMERATION"
}
export declare enum RelationalFieldType {
    Relation = "RELATION",
    Asset = "ASSET"
}
export declare enum ComponentFieldType {
    Component = "COMPONENT"
}
export declare enum UnionFieldType {
    Union = "UNION"
}
export declare enum ComponentUnionFieldType {
    ComponentUnion = "COMPONENT_UNION"
}
export declare enum VisibilityTypes {
    /** Field can be read and edited */
    ReadWrite = "READ_WRITE",
    /** Field is shown but can't be edited in the UI, only through the API */
    ReadOnly = "READ_ONLY",
    /** Field is not shown, but can be used by other fields such as slugs or UI Extensions */
    Hidden = "HIDDEN",
    /** Field is not shown, and can only be read or edited through the API */
    ApiOnly = "API_ONLY"
}
export declare type SimpleField = IField & IRequireableField & IUniqueableField & ILocalizableField & ITitleableField & {
    __typename?: 'SimpleField';
    id: Scalars['ID'];
    type: SimpleFieldType;
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    isSystem: Scalars['Boolean'];
    isList: Scalars['Boolean'];
    isRequired: Scalars['Boolean'];
    isUnique: Scalars['Boolean'];
    position: Scalars['Int'];
    /** @deprecated Use visibility instead */
    isHidden: Scalars['Boolean'];
    visibility: VisibilityTypes;
    isLocalized: Scalars['Boolean'];
    initialValue?: Maybe<Scalars['String']>;
    /**
     * This will throw a runtime error for fields that are on a component instead of model!
     * @deprecated Use parent instead
     */
    model: IModel;
    parent: IFieldParent;
    isTitle: Scalars['Boolean'];
    tableConfig: FieldConfig;
    formConfig: FieldConfig;
    extensions?: Maybe<Scalars['JSON']>;
    validations?: Maybe<SimpleFieldValidations>;
    meta?: Maybe<Scalars['JSON']>;
    embedsEnabled?: Maybe<Scalars['Boolean']>;
    embeddableModels?: Maybe<Array<IModel>>;
    createdBy?: Maybe<CreatedBy>;
};
export declare type RemoteTypeDefinition = {
    __typename?: 'RemoteTypeDefinition';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    apiId: Scalars['String'];
    sdl: Scalars['String'];
    graphqlType: Remote_Graphql_Type;
    isSystem: Scalars['Boolean'];
};
export declare type IRemoteFieldConfig = {
    returnType: RemoteTypeDefinition;
    /** Headers that will be sent to the remote source. Those headers will override the headers defined on the remote source if setup */
    headers?: Maybe<Scalars['JSON']>;
    method: RemoteFieldApiMethod;
    cacheTTLSeconds?: Maybe<Scalars['Int']>;
    remoteSource: IRemoteSource;
    forwardClientHeaders: Scalars['Boolean'];
};
export declare type GraphQlRemoteFieldConfig = IRemoteFieldConfig & {
    __typename?: 'GraphQLRemoteFieldConfig';
    returnType: RemoteTypeDefinition;
    headers?: Maybe<Scalars['JSON']>;
    method: RemoteFieldApiMethod;
    cacheTTLSeconds?: Maybe<Scalars['Int']>;
    forwardClientHeaders: Scalars['Boolean'];
    /** In case of apiType GraphQL graphqlQuery contains the GraphQL query that will be sent to the remote source */
    query?: Maybe<Scalars['String']>;
    operationName?: Maybe<Scalars['String']>;
    remoteSource: GraphQlRemoteSource;
};
export declare type RestRemoteFieldConfig = IRemoteFieldConfig & {
    __typename?: 'RestRemoteFieldConfig';
    returnType: RemoteTypeDefinition;
    headers?: Maybe<Scalars['JSON']>;
    method: RemoteFieldApiMethod;
    cacheTTLSeconds?: Maybe<Scalars['Int']>;
    forwardClientHeaders: Scalars['Boolean'];
    path?: Maybe<Scalars['String']>;
    remoteSource: RestRemoteSource;
};
export declare type RemoteField = IField & {
    __typename?: 'RemoteField';
    id: Scalars['ID'];
    type: RemoteFieldType;
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    isSystem: Scalars['Boolean'];
    position: Scalars['Int'];
    /** @deprecated Use visibility instead */
    isHidden: Scalars['Boolean'];
    visibility: VisibilityTypes;
    isList: Scalars['Boolean'];
    isRequired: Scalars['Boolean'];
    /**
     * This will throw a runtime error for fields that are on a component instead of model!
     * @deprecated Use parent instead
     */
    model: IModel;
    parent: IFieldParent;
    tableConfig: FieldConfig;
    formConfig: FieldConfig;
    extensions?: Maybe<Scalars['JSON']>;
    meta?: Maybe<Scalars['JSON']>;
    remoteConfig: IRemoteFieldConfig;
    inputArgs?: Maybe<Array<FieldInputArg>>;
    createdBy?: Maybe<CreatedBy>;
};
export declare type EnumerableField = IField & IRequireableField & IUniqueableField & ILocalizableField & ITitleableField & {
    __typename?: 'EnumerableField';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    type: EnumerableFieldType;
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    isSystem: Scalars['Boolean'];
    isList: Scalars['Boolean'];
    isRequired: Scalars['Boolean'];
    isUnique: Scalars['Boolean'];
    position: Scalars['Int'];
    /** @deprecated Use visibility instead */
    isHidden: Scalars['Boolean'];
    visibility: VisibilityTypes;
    isLocalized: Scalars['Boolean'];
    initialValue?: Maybe<EnumerationValue>;
    /**
     * This will throw a runtime error for fields that are on a component instead of model!
     * @deprecated Use parent instead
     */
    model: IModel;
    parent: IFieldParent;
    isTitle: Scalars['Boolean'];
    tableConfig: FieldConfig;
    formConfig: FieldConfig;
    enumeration: Enumeration;
    extensions?: Maybe<Scalars['JSON']>;
    meta?: Maybe<Scalars['JSON']>;
    createdBy?: Maybe<CreatedBy>;
};
export declare type RelationalField = IField & IRequireableField & {
    __typename?: 'RelationalField';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    type: RelationalFieldType;
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    isSystem: Scalars['Boolean'];
    isList: Scalars['Boolean'];
    isRequired: Scalars['Boolean'];
    position: Scalars['Int'];
    /** @deprecated Use visibility instead */
    isHidden: Scalars['Boolean'];
    visibility: VisibilityTypes;
    /**
     * This will throw a runtime error for fields that are on a component instead of model!
     * @deprecated Use parent instead
     */
    model: IModel;
    parent: IFieldParent;
    tableConfig: FieldConfig;
    formConfig: FieldConfig;
    relatedModel: IModel;
    relatedField: RelationalField;
    extensions?: Maybe<Scalars['JSON']>;
    meta?: Maybe<Scalars['JSON']>;
    createdBy?: Maybe<CreatedBy>;
};
export declare type UniDirectionalRelationalField = IField & IRequireableField & {
    __typename?: 'UniDirectionalRelationalField';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    type: RelationalFieldType;
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    isSystem: Scalars['Boolean'];
    isList: Scalars['Boolean'];
    isRequired: Scalars['Boolean'];
    position: Scalars['Int'];
    /** @deprecated Use visibility instead */
    isHidden: Scalars['Boolean'];
    visibility: VisibilityTypes;
    /**
     * This will throw a runtime error for fields that are on a component instead of model!
     * @deprecated Use parent instead
     */
    model: IModel;
    parent: IFieldParent;
    tableConfig: FieldConfig;
    formConfig: FieldConfig;
    relatedModel: IModel;
    extensions?: Maybe<Scalars['JSON']>;
    meta?: Maybe<Scalars['JSON']>;
    createdBy?: Maybe<CreatedBy>;
};
export declare type ComponentField = IField & IRequireableField & {
    __typename?: 'ComponentField';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    type: ComponentFieldType;
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    isSystem: Scalars['Boolean'];
    isList: Scalars['Boolean'];
    isRequired: Scalars['Boolean'];
    position: Scalars['Int'];
    /** @deprecated Use visibility instead */
    isHidden: Scalars['Boolean'];
    visibility: VisibilityTypes;
    /**
     * This will throw a runtime error for fields that are on a component instead of model!
     * @deprecated Use parent instead
     */
    model: IModel;
    parent: IFieldParent;
    hasEmptyValues: Scalars['Boolean'];
    tableConfig: FieldConfig;
    formConfig: FieldConfig;
    component: Component;
    extensions?: Maybe<Scalars['JSON']>;
    meta?: Maybe<Scalars['JSON']>;
    createdBy?: Maybe<CreatedBy>;
};
export declare type UnionField = IField & IUnionField & {
    __typename?: 'UnionField';
    id: Scalars['ID'];
    type: UnionFieldType;
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    isSystem: Scalars['Boolean'];
    isList: Scalars['Boolean'];
    position: Scalars['Int'];
    /** @deprecated Use visibility instead */
    isHidden: Scalars['Boolean'];
    visibility: VisibilityTypes;
    /**
     * This will throw a runtime error for fields that are on a component instead of model!
     * @deprecated Use parent instead
     */
    model: IModel;
    parent: IFieldParent;
    tableConfig: FieldConfig;
    formConfig: FieldConfig;
    /** True if this field is the reverse side of the initally created union field */
    isMemberType: Scalars['Boolean'];
    union: Union;
    extensions?: Maybe<Scalars['JSON']>;
    meta?: Maybe<Scalars['JSON']>;
    createdBy?: Maybe<CreatedBy>;
};
export declare type ComponentUnionField = IField & IRequireableField & {
    __typename?: 'ComponentUnionField';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    type: ComponentUnionFieldType;
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    isSystem: Scalars['Boolean'];
    isList: Scalars['Boolean'];
    isRequired: Scalars['Boolean'];
    position: Scalars['Int'];
    /** @deprecated Use visibility instead */
    isHidden: Scalars['Boolean'];
    visibility: VisibilityTypes;
    /**
     * This will throw a runtime error for fields that are on a component instead of model!
     * @deprecated Use parent instead
     */
    model: IModel;
    parent: IFieldParent;
    tableConfig: FieldConfig;
    formConfig: FieldConfig;
    components: Array<Component>;
    extensions?: Maybe<Scalars['JSON']>;
    meta?: Maybe<Scalars['JSON']>;
    createdBy?: Maybe<CreatedBy>;
};
export declare type Union = {
    __typename?: 'Union';
    id: Scalars['ID'];
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    memberTypes: Array<UnionField>;
    field: UnionField;
};
export declare type IUnionField = {
    /** True if this field is the reverse side of the initally created union field */
    isMemberType: Scalars['Boolean'];
    union: Union;
};
export declare type FieldConfig = {
    __typename?: 'FieldConfig';
    config: Scalars['JSON'];
    id: Scalars['String'];
    renderer: Scalars['String'];
    extension?: Maybe<FieldExtension>;
    appInstallation?: Maybe<AppInstallation>;
    appElement?: Maybe<FieldAppElement>;
};
export declare type FieldValidationIntRangeInput = {
    min?: InputMaybe<Scalars['Int']>;
    max?: InputMaybe<Scalars['Int']>;
    errorMessage?: InputMaybe<Scalars['String']>;
};
export declare type FieldValidationFloatRangeInput = {
    min?: InputMaybe<Scalars['Float']>;
    max?: InputMaybe<Scalars['Float']>;
    errorMessage?: InputMaybe<Scalars['String']>;
};
export declare type FieldValidationRegExInput = {
    regex?: InputMaybe<Scalars['String']>;
    flags?: InputMaybe<Array<Scalars['String']>>;
    errorMessage?: InputMaybe<Scalars['String']>;
};
export declare type IntFieldValidationsInput = {
    range?: InputMaybe<FieldValidationIntRangeInput>;
    listItemCount?: InputMaybe<FieldValidationIntRangeInput>;
};
export declare type FloatFieldValidationsInput = {
    range?: InputMaybe<FieldValidationFloatRangeInput>;
    listItemCount?: InputMaybe<FieldValidationIntRangeInput>;
};
export declare type StringFieldValidationsInput = {
    characters?: InputMaybe<FieldValidationIntRangeInput>;
    listItemCount?: InputMaybe<FieldValidationIntRangeInput>;
    matches?: InputMaybe<FieldValidationRegExInput>;
    notMatches?: InputMaybe<FieldValidationRegExInput>;
};
export declare type SimpleFieldValidationsInput = {
    Int?: InputMaybe<IntFieldValidationsInput>;
    Float?: InputMaybe<FloatFieldValidationsInput>;
    String?: InputMaybe<StringFieldValidationsInput>;
};
export declare type FieldConfigInput = {
    renderer: Scalars['String'];
    config: Scalars['JSON'];
    extensionId?: InputMaybe<Scalars['ID']>;
    appInstallationId?: InputMaybe<Scalars['ID']>;
    appElementId?: InputMaybe<Scalars['ID']>;
};
export declare type FieldInputArg = {
    __typename?: 'FieldInputArg';
    id: Scalars['ID'];
    apiId: Scalars['String'];
    isRequired: Scalars['Boolean'];
    isList: Scalars['Boolean'];
    remoteType: RemoteTypeDefinition;
};
export declare type BatchMigrationRemoteFieldInputArgInput = {
    remoteTypeApiId: Scalars['String'];
    apiId: Scalars['String'];
    isRequired: Scalars['Boolean'];
    isList: Scalars['Boolean'];
};
export declare type BatchMigrationRemoteFieldConfigInput = {
    returnTypeApiId: Scalars['String'];
    headers?: InputMaybe<Scalars['JSON']>;
    method: RemoteFieldApiMethod;
    cacheTTLSeconds?: InputMaybe<Scalars['Int']>;
    remoteSourcePrefix: Scalars['String'];
    /** In case of apiType GraphQL graphqlQuery contains the GraphQL query that will be sent to the remote source */
    graphQLQuery?: InputMaybe<Scalars['String']>;
    /** In case of apiType REST restPath contains the path that will be appended to the API base url */
    restPath?: InputMaybe<Scalars['String']>;
    /** If true, headers that are sent by the client will be forwarded to the remote source */
    forwardClientHeaders?: InputMaybe<Scalars['Boolean']>;
};
export declare type BatchMigrationUpdateRemoteFieldConfigInput = {
    returnTypeApiId?: InputMaybe<Scalars['String']>;
    remoteSourcePrefix?: InputMaybe<Scalars['String']>;
    headers?: InputMaybe<Scalars['JSON']>;
    method?: InputMaybe<RemoteFieldApiMethod>;
    cacheTTLSeconds?: InputMaybe<Scalars['Int']>;
    /** In case of apiType GraphQL graphqlQuery contains the GraphQL query that will be sent to the remote source */
    graphQLQuery?: InputMaybe<Scalars['String']>;
    /** In case of apiType REST restPath contains the path that will be appended to the API base url */
    restPath?: InputMaybe<Scalars['String']>;
    /** If true, headers that are sent by the client will be forwarded to the remote source */
    forwardClientHeaders?: InputMaybe<Scalars['Boolean']>;
};
export declare type BatchMigrationUpsertFieldInputArgInputToCreateInput = {
    remoteTypeApiId: Scalars['String'];
    apiId: Scalars['String'];
    isRequired: Scalars['Boolean'];
    isList: Scalars['Boolean'];
};
export declare type BatchMigrationUpsertFieldInputArgInputToUpdateInput = {
    argApiId: Scalars['String'];
    remoteTypeApiId?: InputMaybe<Scalars['String']>;
    apiId?: InputMaybe<Scalars['String']>;
    isRequired?: InputMaybe<Scalars['Boolean']>;
    isList?: InputMaybe<Scalars['Boolean']>;
};
export declare type BatchMigrationUpsertFieldInputArgInputToDeleteInput = {
    argApiId: Scalars['String'];
};
export declare type BatchMigrationUpsertFieldInputArgInput = {
    fieldInputArgsToCreate?: InputMaybe<Array<BatchMigrationUpsertFieldInputArgInputToCreateInput>>;
    fieldInputArgsToDelete?: InputMaybe<Array<BatchMigrationUpsertFieldInputArgInputToDeleteInput>>;
    fieldInputArgsToUpdate?: InputMaybe<Array<BatchMigrationUpsertFieldInputArgInputToUpdateInput>>;
};
/**
 * This types holds a superset of the allowed read operations on a model.
 * This means even if this states access is allowed, it could still potentially be denied.
 */
export declare type ModelViewerReadContentPermission = {
    __typename?: 'ModelViewerReadContentPermission';
    allowedWithCondition: Scalars['Boolean'];
    allowedLocales: Array<Locale>;
};
export declare type ModelViewerReadContentPermissionByStage = {
    __typename?: 'ModelViewerReadContentPermissionByStage';
    stage: Stage;
    /**
     * If the current viewer is allowed to read this models content for the provided stage,
     * this field will return the potential limitations that must be met.
     * `null` means not allowed!
     */
    allowed?: Maybe<ModelViewerReadContentPermission>;
};
export declare type ModelViewerContentPermission = {
    __typename?: 'ModelViewerContentPermission';
    /** Lists all stages and the corresponding read permissions the user has on those stages. */
    readByStages: Array<ModelViewerReadContentPermissionByStage>;
    readVersion: Scalars['Boolean'];
};
/** Simplified computed version of the permissions the current viewer has on this model */
export declare type ModelViewerPermission = {
    __typename?: 'ModelViewerPermission';
    content: ModelViewerContentPermission;
};
export declare type IFieldParent = {
    id: Scalars['ID'];
    apiId: Scalars['String'];
    displayName: Scalars['String'];
};
export declare type CreatedBy = PermanentAuthToken | Member | AppToken;
export declare type IModel = {
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    createdBy?: Maybe<CreatedBy>;
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    isSystem: Scalars['Boolean'];
    apiIdPlural: Scalars['String'];
    isLocalized: Scalars['Boolean'];
    titleFields: Array<IField>;
    fields: Array<IField>;
    field: IField;
    environment: Environment;
    contentViews: Array<ContentView>;
    /** Model has at least one document */
    hasContent: Scalars['Boolean'];
    isVersioned: Scalars['Boolean'];
    viewerPermission: ModelViewerPermission;
    sidebarElements: Array<ISidebarElement>;
    hasLocalizedComponents: Scalars['Boolean'];
};
export declare type IModelFieldsArgs = {
    includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
    includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
};
export declare type IModelFieldArgs = {
    id: Scalars['ID'];
};
export declare type IModelContentViewsArgs = {
    includeSystemContentViews?: InputMaybe<Scalars['Boolean']>;
    filter?: InputMaybe<ContentViewFilterInput>;
};
export declare type ISidebarElement = {
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    config?: Maybe<Scalars['JSON']>;
    position: Scalars['Int'];
    isEnabled: Scalars['Boolean'];
    model: IModel;
};
export declare type CustomSidebarElement = ISidebarElement & {
    __typename?: 'CustomSidebarElement';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    config?: Maybe<Scalars['JSON']>;
    position: Scalars['Int'];
    isEnabled: Scalars['Boolean'];
    model: IModel;
    extension: SidebarExtension;
};
export declare enum SystemSidebarElementType {
    Information = "INFORMATION",
    Stages = "STAGES",
    Localizations = "LOCALIZATIONS",
    Versions = "VERSIONS",
    PreviewUrls = "PREVIEW_URLS",
    Releases = "RELEASES"
}
export declare type SystemSidebarElement = ISidebarElement & {
    __typename?: 'SystemSidebarElement';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    config?: Maybe<Scalars['JSON']>;
    position: Scalars['Int'];
    isEnabled: Scalars['Boolean'];
    model: IModel;
    type: SystemSidebarElementType;
};
export declare type ExtensionSidebarElement = ISidebarElement & {
    __typename?: 'ExtensionSidebarElement';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    config?: Maybe<Scalars['JSON']>;
    position: Scalars['Int'];
    isEnabled: Scalars['Boolean'];
    model: IModel;
    extension: SidebarExtension;
};
export declare type AppSidebarElement = ISidebarElement & {
    __typename?: 'AppSidebarElement';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    config?: Maybe<Scalars['JSON']>;
    position: Scalars['Int'];
    isEnabled: Scalars['Boolean'];
    model: IModel;
    appElement: FormSidebarAppElement;
    appInstallation: AppInstallation;
};
export declare type Model = IModel & IFieldParent & {
    __typename?: 'Model';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    createdBy?: Maybe<CreatedBy>;
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    isSystem: Scalars['Boolean'];
    apiIdPlural: Scalars['String'];
    /** Is true when at least one field is marked as localized */
    isLocalized: Scalars['Boolean'];
    titleFields: Array<IField>;
    fields: Array<IField>;
    field: IField;
    environment: Environment;
    contentViews: Array<ContentView>;
    /** Model has at least one document */
    hasContent: Scalars['Boolean'];
    isVersioned: Scalars['Boolean'];
    viewerPermission: ModelViewerPermission;
    sidebarElements: Array<ISidebarElement>;
    hasLocalizedComponents: Scalars['Boolean'];
};
export declare type ModelFieldsArgs = {
    includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
    includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
};
export declare type ModelFieldArgs = {
    id: Scalars['ID'];
};
export declare type ModelContentViewsArgs = {
    includeSystemContentViews?: InputMaybe<Scalars['Boolean']>;
    filter?: InputMaybe<ContentViewFilterInput>;
};
export declare type Component = IFieldParent & {
    __typename?: 'Component';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    createdBy?: Maybe<CreatedBy>;
    apiId: Scalars['String'];
    apiIdPlural: Scalars['String'];
    isSystem: Scalars['Boolean'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    /** Is true when at least one field is marked as localized */
    isLocalized: Scalars['Boolean'];
    titleFields: Array<IField>;
    fields: Array<IField>;
    environment: Environment;
    /** Component has at least one instance in any of its usages */
    hasContent: Scalars['Boolean'];
};
export declare type ComponentFieldsArgs = {
    includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
    includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
};
export declare type AssetModel = IModel & IFieldParent & {
    __typename?: 'AssetModel';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    createdBy?: Maybe<CreatedBy>;
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    isSystem: Scalars['Boolean'];
    apiIdPlural: Scalars['String'];
    isLocalized: Scalars['Boolean'];
    titleFields: Array<IField>;
    fields: Array<IField>;
    field: IField;
    environment: Environment;
    contentViews: Array<ContentView>;
    /** Model has at least one document */
    hasContent: Scalars['Boolean'];
    isVersioned: Scalars['Boolean'];
    viewerPermission: ModelViewerPermission;
    sidebarElements: Array<ISidebarElement>;
    hasLocalizedComponents: Scalars['Boolean'];
};
export declare type AssetModelFieldsArgs = {
    includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
    includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
};
export declare type AssetModelFieldArgs = {
    id: Scalars['ID'];
};
export declare type AssetModelContentViewsArgs = {
    includeSystemContentViews?: InputMaybe<Scalars['Boolean']>;
    filter?: InputMaybe<ContentViewFilterInput>;
};
export declare type UserModel = IModel & IFieldParent & {
    __typename?: 'UserModel';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    createdBy?: Maybe<CreatedBy>;
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    isSystem: Scalars['Boolean'];
    apiIdPlural: Scalars['String'];
    isLocalized: Scalars['Boolean'];
    titleFields: Array<IField>;
    fields: Array<IField>;
    field: IField;
    environment: Environment;
    contentViews: Array<ContentView>;
    /** Model has at least one document */
    hasContent: Scalars['Boolean'];
    isVersioned: Scalars['Boolean'];
    viewerPermission: ModelViewerPermission;
    sidebarElements: Array<ISidebarElement>;
    hasLocalizedComponents: Scalars['Boolean'];
};
export declare type UserModelFieldsArgs = {
    includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
    includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
};
export declare type UserModelFieldArgs = {
    id: Scalars['ID'];
};
export declare type UserModelContentViewsArgs = {
    includeSystemContentViews?: InputMaybe<Scalars['Boolean']>;
    filter?: InputMaybe<ContentViewFilterInput>;
};
export declare type SchedulingModel = IModel & IFieldParent & {
    __typename?: 'SchedulingModel';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    createdBy?: Maybe<CreatedBy>;
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    isSystem: Scalars['Boolean'];
    apiIdPlural: Scalars['String'];
    isLocalized: Scalars['Boolean'];
    titleFields: Array<IField>;
    fields: Array<IField>;
    field: IField;
    environment: Environment;
    contentViews: Array<ContentView>;
    /** Model has at least one document */
    hasContent: Scalars['Boolean'];
    isVersioned: Scalars['Boolean'];
    viewerPermission: ModelViewerPermission;
    sidebarElements: Array<ISidebarElement>;
    hasLocalizedComponents: Scalars['Boolean'];
};
export declare type SchedulingModelFieldsArgs = {
    includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
    includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
};
export declare type SchedulingModelFieldArgs = {
    id: Scalars['ID'];
};
export declare type SchedulingModelContentViewsArgs = {
    includeSystemContentViews?: InputMaybe<Scalars['Boolean']>;
    filter?: InputMaybe<ContentViewFilterInput>;
};
export declare type Locale = {
    __typename?: 'Locale';
    id: Scalars['ID'];
    createdAt: Scalars['DateTime'];
    updatedAt: Scalars['DateTime'];
    /**
     * Specifies if the locale is used as the
     * default locale which impacts the Content API
     */
    isDefault: Scalars['Boolean'];
    /**
     * Determines how the locale is
     * exposed in the Content API
     */
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: Maybe<Scalars['String']>;
};
export declare type AsyncOperationPayload = {
    __typename?: 'AsyncOperationPayload';
    migration: Migration;
};
/** Creating a model. */
export declare type BatchMigrationCreateModelInput = {
    /** The model apiId */
    apiId: Scalars['String'];
    /** The models plural apiId. This is used for lists */
    apiIdPlural: Scalars['String'];
    /** Display name that is used to render the model in the webapp */
    displayName: Scalars['String'];
    /** Optional description of the model */
    description?: InputMaybe<Scalars['String']>;
    /** Only AppTokens should provide this flag */
    isSystem?: InputMaybe<Scalars['Boolean']>;
};
/** Updating a model. */
export declare type BatchMigrationUpdateModelInput = {
    apiId: Scalars['String'];
    newApiId?: InputMaybe<Scalars['String']>;
    apiIdPlural?: InputMaybe<Scalars['String']>;
    displayName?: InputMaybe<Scalars['String']>;
    description?: InputMaybe<Scalars['String']>;
    isSystem?: InputMaybe<Scalars['Boolean']>;
};
/** Deleting a model. */
export declare type BatchMigrationDeleteModelInput = {
    apiId: Scalars['String'];
};
/** Creating a component. */
export declare type BatchMigrationCreateComponentInput = {
    apiId: Scalars['String'];
    apiIdPlural: Scalars['String'];
    displayName: Scalars['String'];
    description?: InputMaybe<Scalars['String']>;
};
/** Updating a component. */
export declare type BatchMigrationUpdateComponentInput = {
    apiId: Scalars['String'];
    newApiId?: InputMaybe<Scalars['String']>;
    apiIdPlural?: InputMaybe<Scalars['String']>;
    displayName?: InputMaybe<Scalars['String']>;
    description?: InputMaybe<Scalars['String']>;
};
/** Deleting a component. */
export declare type BatchMigrationDeleteComponentInput = {
    apiId: Scalars['String'];
};
/** Deleting a stage. */
export declare type BatchMigrationDeleteStageInput = {
    apiId: Scalars['String'];
};
/** Updating a stage */
export declare type BatchMigrationUpdateStageInput = {
    apiId: Scalars['String'];
    newApiId?: InputMaybe<Scalars['String']>;
    color?: InputMaybe<ColorPalette>;
    display?: InputMaybe<Scalars['String']>;
    description?: InputMaybe<Scalars['String']>;
    position?: InputMaybe<Scalars['Int']>;
};
/** Creating a stage. */
export declare type BatchMigrationCreateStageInput = {
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    color: ColorPalette;
    description?: InputMaybe<Scalars['String']>;
    position?: InputMaybe<Scalars['Int']>;
};
/** Deleting a field. */
export declare type BatchMigrationDeleteFieldInput = {
    apiId: Scalars['String'];
    modelApiId?: InputMaybe<Scalars['String']>;
    parentApiId?: InputMaybe<Scalars['String']>;
};
/** Creating a simple field. */
export declare type BatchMigrationEmbeddableModelsInput = {
    modelsToAdd?: InputMaybe<Array<Scalars['String']>>;
    modelsToRemove?: InputMaybe<Array<Scalars['String']>>;
};
/** Creating a simple field. */
export declare type BatchMigrationCreateSimpleFieldInput = {
    apiId: Scalars['String'];
    modelApiId?: InputMaybe<Scalars['String']>;
    parentApiId?: InputMaybe<Scalars['String']>;
    type: SimpleFieldType;
    displayName: Scalars['String'];
    description?: InputMaybe<Scalars['String']>;
    initialValue?: InputMaybe<Scalars['String']>;
    tableRenderer?: InputMaybe<Scalars['String']>;
    formRenderer?: InputMaybe<Scalars['String']>;
    tableExtension?: InputMaybe<Scalars['String']>;
    formExtension?: InputMaybe<Scalars['String']>;
    formConfig?: InputMaybe<Scalars['JSON']>;
    tableConfig?: InputMaybe<Scalars['JSON']>;
    isList?: InputMaybe<Scalars['Boolean']>;
    isLocalized?: InputMaybe<Scalars['Boolean']>;
    isRequired?: InputMaybe<Scalars['Boolean']>;
    isUnique?: InputMaybe<Scalars['Boolean']>;
    isHidden?: InputMaybe<Scalars['Boolean']>;
    visibility?: InputMaybe<VisibilityTypes>;
    isTitle?: InputMaybe<Scalars['Boolean']>;
    position?: InputMaybe<Scalars['Int']>;
    validations?: InputMaybe<SimpleFieldValidationsInput>;
    migrationValue?: InputMaybe<Scalars['String']>;
    embedsEnabled?: InputMaybe<Scalars['Boolean']>;
    embeddableModels?: InputMaybe<Array<Scalars['String']>>;
    isSystem?: InputMaybe<Scalars['Boolean']>;
};
export declare type BatchMigrationCreateRemoteFieldInput = {
    apiId: Scalars['String'];
    parentApiId: Scalars['String'];
    type: RemoteFieldType;
    displayName: Scalars['String'];
    description?: InputMaybe<Scalars['String']>;
    tableRenderer?: InputMaybe<Scalars['String']>;
    formRenderer?: InputMaybe<Scalars['String']>;
    tableExtension?: InputMaybe<Scalars['String']>;
    formExtension?: InputMaybe<Scalars['String']>;
    formConfig?: InputMaybe<Scalars['JSON']>;
    tableConfig?: InputMaybe<Scalars['JSON']>;
    isList?: InputMaybe<Scalars['Boolean']>;
    isRequired?: InputMaybe<Scalars['Boolean']>;
    visibility?: InputMaybe<VisibilityTypes>;
    position?: InputMaybe<Scalars['Int']>;
    remoteConfig: BatchMigrationRemoteFieldConfigInput;
    inputArgs?: InputMaybe<Array<BatchMigrationRemoteFieldInputArgInput>>;
};
export declare type BatchMigrationUpdateRemoteFieldInput = {
    apiId: Scalars['String'];
    newApiId?: InputMaybe<Scalars['String']>;
    parentApiId: Scalars['String'];
    remoteConfig?: InputMaybe<BatchMigrationUpdateRemoteFieldConfigInput>;
    inputArgs?: InputMaybe<BatchMigrationUpsertFieldInputArgInput>;
    isList?: InputMaybe<Scalars['Boolean']>;
    isRequired?: InputMaybe<Scalars['Boolean']>;
    displayName?: InputMaybe<Scalars['String']>;
    description?: InputMaybe<Scalars['String']>;
    visibility?: InputMaybe<VisibilityTypes>;
    formConfig?: InputMaybe<FieldConfigInput>;
    tableConfig?: InputMaybe<FieldConfigInput>;
    extensions?: InputMaybe<Scalars['JSON']>;
    meta?: InputMaybe<Scalars['JSON']>;
};
/** Creating an enumerable field. */
export declare type BatchMigrationCreateEnumerableFieldInput = {
    apiId: Scalars['String'];
    modelApiId?: InputMaybe<Scalars['String']>;
    parentApiId?: InputMaybe<Scalars['String']>;
    enumerationApiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: InputMaybe<Scalars['String']>;
    tableRenderer?: InputMaybe<Scalars['String']>;
    formRenderer?: InputMaybe<Scalars['String']>;
    tableExtension?: InputMaybe<Scalars['String']>;
    formExtension?: InputMaybe<Scalars['String']>;
    isList?: InputMaybe<Scalars['Boolean']>;
    isLocalized?: InputMaybe<Scalars['Boolean']>;
    isRequired?: InputMaybe<Scalars['Boolean']>;
    isUnique?: InputMaybe<Scalars['Boolean']>;
    isHidden?: InputMaybe<Scalars['Boolean']>;
    migrationValue?: InputMaybe<Scalars['String']>;
    visibility?: InputMaybe<VisibilityTypes>;
    isTitle?: InputMaybe<Scalars['Boolean']>;
    position?: InputMaybe<Scalars['Int']>;
    isSystem?: InputMaybe<Scalars['Boolean']>;
};
/** updating a union field */
export declare type BatchMigrationUpdateUnionFieldInput = {
    apiId: Scalars['String'];
    newApiId?: InputMaybe<Scalars['String']>;
    modelApiId?: InputMaybe<Scalars['String']>;
    parentApiId?: InputMaybe<Scalars['String']>;
    displayName?: InputMaybe<Scalars['String']>;
    description?: InputMaybe<Scalars['String']>;
    visibility?: InputMaybe<VisibilityTypes>;
    reverseField?: InputMaybe<BatchMigrationUpdateReverseUnionFieldInput>;
};
/** Creating a union field */
export declare type BatchMigrationCreateUnionFieldInput = {
    apiId: Scalars['String'];
    modelApiId?: InputMaybe<Scalars['String']>;
    parentApiId?: InputMaybe<Scalars['String']>;
    displayName: Scalars['String'];
    description?: InputMaybe<Scalars['String']>;
    tableRenderer?: InputMaybe<Scalars['String']>;
    formRenderer?: InputMaybe<Scalars['String']>;
    tableExtension?: InputMaybe<Scalars['String']>;
    formExtension?: InputMaybe<Scalars['String']>;
    isList?: InputMaybe<Scalars['Boolean']>;
    isHidden?: InputMaybe<Scalars['Boolean']>;
    visibility?: InputMaybe<VisibilityTypes>;
    reverseField: BatchMigrationCreateReverseUnionFieldInput;
};
/** updating a component-union field */
export declare type BatchMigrationUpdateComponentUnionFieldInput = {
    apiId: Scalars['String'];
    newApiId?: InputMaybe<Scalars['String']>;
    parentApiId: Scalars['String'];
    displayName?: InputMaybe<Scalars['String']>;
    description?: InputMaybe<Scalars['String']>;
    componentApiIds?: InputMaybe<Array<Scalars['String']>>;
};
/** Creating a component-union field */
export declare type BatchMigrationCreateComponentUnionFieldInput = {
    apiId: Scalars['String'];
    parentApiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: InputMaybe<Scalars['String']>;
    tableRenderer?: InputMaybe<Scalars['String']>;
    formRenderer?: InputMaybe<Scalars['String']>;
    tableExtension?: InputMaybe<Scalars['String']>;
    formExtension?: InputMaybe<Scalars['String']>;
    isList?: InputMaybe<Scalars['Boolean']>;
    isRequired?: InputMaybe<Scalars['Boolean']>;
    visibility?: InputMaybe<VisibilityTypes>;
    componentApiIds: Array<Scalars['String']>;
};
/** reverse field args */
export declare type BatchMigrationCreateReverseUnionFieldInput = {
    apiId?: InputMaybe<Scalars['String']>;
    modelApiIds: Array<Scalars['String']>;
    displayName?: InputMaybe<Scalars['String']>;
    description?: InputMaybe<Scalars['String']>;
    isList?: InputMaybe<Scalars['Boolean']>;
    isHidden?: InputMaybe<Scalars['Boolean']>;
    visibility?: InputMaybe<VisibilityTypes>;
};
/** reverse field args */
export declare type BatchMigrationUpdateReverseUnionFieldInput = {
    modelApiIds: Array<Scalars['String']>;
};
/** Creating a relational field */
export declare type BatchMigrationCreateRelationalFieldInput = {
    apiId: Scalars['String'];
    modelApiId?: InputMaybe<Scalars['String']>;
    parentApiId?: InputMaybe<Scalars['String']>;
    type: RelationalFieldType;
    displayName: Scalars['String'];
    description?: InputMaybe<Scalars['String']>;
    tableRenderer?: InputMaybe<Scalars['String']>;
    formRenderer?: InputMaybe<Scalars['String']>;
    tableExtension?: InputMaybe<Scalars['String']>;
    formExtension?: InputMaybe<Scalars['String']>;
    isList?: InputMaybe<Scalars['Boolean']>;
    /**
     * Marks the field as required.
     * Note: This is only supported for RelationFieldType ASSET!
     */
    isRequired?: InputMaybe<Scalars['Boolean']>;
    isHidden?: InputMaybe<Scalars['Boolean']>;
    visibility?: InputMaybe<VisibilityTypes>;
    reverseField: BatchMigrationCreateReverseRelationalFieldInput;
};
/** Creating a component field */
export declare type BatchMigrationCreateComponentFieldInput = {
    apiId: Scalars['String'];
    parentApiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: InputMaybe<Scalars['String']>;
    tableRenderer?: InputMaybe<Scalars['String']>;
    formRenderer?: InputMaybe<Scalars['String']>;
    tableExtension?: InputMaybe<Scalars['String']>;
    formExtension?: InputMaybe<Scalars['String']>;
    isList?: InputMaybe<Scalars['Boolean']>;
    isRequired?: InputMaybe<Scalars['Boolean']>;
    visibility?: InputMaybe<VisibilityTypes>;
    componentApiId: Scalars['String'];
    position?: InputMaybe<Scalars['Int']>;
};
/** reverse field args */
export declare type BatchMigrationCreateReverseRelationalFieldInput = {
    apiId: Scalars['String'];
    modelApiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: InputMaybe<Scalars['String']>;
    isList?: InputMaybe<Scalars['Boolean']>;
    isHidden?: InputMaybe<Scalars['Boolean']>;
    visibility?: InputMaybe<VisibilityTypes>;
    isUnidirectional?: InputMaybe<Scalars['Boolean']>;
};
/** Updating relational field */
export declare type BatchMigrationUpdateRelationalFieldInput = {
    apiId: Scalars['String'];
    newApiId?: InputMaybe<Scalars['String']>;
    modelApiId?: InputMaybe<Scalars['String']>;
    parentApiId?: InputMaybe<Scalars['String']>;
    displayName?: InputMaybe<Scalars['String']>;
    description?: InputMaybe<Scalars['String']>;
    isList?: InputMaybe<Scalars['Boolean']>;
    isHidden?: InputMaybe<Scalars['Boolean']>;
    visibility?: InputMaybe<VisibilityTypes>;
    isUnidirectional?: InputMaybe<Scalars['Boolean']>;
    /**
     * Marks the field as required.
     * Note: This is only supported for RelationFieldType ASSET!
     */
    isRequired?: InputMaybe<Scalars['Boolean']>;
};
/** Updating component field */
export declare type BatchMigrationUpdateComponentFieldInput = {
    apiId: Scalars['String'];
    newApiId?: InputMaybe<Scalars['String']>;
    parentApiId: Scalars['String'];
    displayName?: InputMaybe<Scalars['String']>;
    description?: InputMaybe<Scalars['String']>;
    isList?: InputMaybe<Scalars['Boolean']>;
    visibility?: InputMaybe<VisibilityTypes>;
    isRequired?: InputMaybe<Scalars['Boolean']>;
};
/** Updating simple field */
export declare type BatchMigrationUpdateSimpleFieldInput = {
    apiId: Scalars['String'];
    newApiId?: InputMaybe<Scalars['String']>;
    modelApiId?: InputMaybe<Scalars['String']>;
    parentApiId?: InputMaybe<Scalars['String']>;
    displayName?: InputMaybe<Scalars['String']>;
    description?: InputMaybe<Scalars['String']>;
    isList?: InputMaybe<Scalars['Boolean']>;
    isLocalized?: InputMaybe<Scalars['Boolean']>;
    isRequired?: InputMaybe<Scalars['Boolean']>;
    isUnique?: InputMaybe<Scalars['Boolean']>;
    isHidden?: InputMaybe<Scalars['Boolean']>;
    visibility?: InputMaybe<VisibilityTypes>;
    isTitle?: InputMaybe<Scalars['Boolean']>;
    position?: InputMaybe<Scalars['Int']>;
    initialValue?: InputMaybe<Scalars['String']>;
    migrationValue?: InputMaybe<Scalars['String']>;
    validations?: InputMaybe<SimpleFieldValidationsInput>;
    embedsEnabled?: InputMaybe<Scalars['Boolean']>;
    tableRenderer?: InputMaybe<Scalars['String']>;
    formRenderer?: InputMaybe<Scalars['String']>;
    tableExtension?: InputMaybe<Scalars['String']>;
    formExtension?: InputMaybe<Scalars['String']>;
    formConfig?: InputMaybe<Scalars['JSON']>;
    tableConfig?: InputMaybe<Scalars['JSON']>;
    embeddableModels?: InputMaybe<BatchMigrationEmbeddableModelsInput>;
    isSystem?: InputMaybe<Scalars['Boolean']>;
};
/** Updating enumerable field */
export declare type BatchMigrationUpdateEnumerableFieldInput = {
    apiId: Scalars['String'];
    newApiId?: InputMaybe<Scalars['String']>;
    modelApiId?: InputMaybe<Scalars['String']>;
    parentApiId?: InputMaybe<Scalars['String']>;
    displayName?: InputMaybe<Scalars['String']>;
    description?: InputMaybe<Scalars['String']>;
    isList?: InputMaybe<Scalars['Boolean']>;
    isLocalized?: InputMaybe<Scalars['Boolean']>;
    isRequired?: InputMaybe<Scalars['Boolean']>;
    isUnique?: InputMaybe<Scalars['Boolean']>;
    isHidden?: InputMaybe<Scalars['Boolean']>;
    visibility?: InputMaybe<VisibilityTypes>;
    isTitle?: InputMaybe<Scalars['Boolean']>;
    position?: InputMaybe<Scalars['Int']>;
    initialValue?: InputMaybe<Scalars['String']>;
    migrationValue?: InputMaybe<Scalars['String']>;
    isSystem?: InputMaybe<Scalars['Boolean']>;
};
/** Deleting enumarable field */
export declare type BatchMigrationDeleteEnumerationInput = {
    apiId: Scalars['String'];
};
/** Creating enumeration */
export declare type BatchMigrationCreateEnumerationInput = {
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: InputMaybe<Scalars['String']>;
    values: Array<BatchMigrationCreateEnumerationValueInput>;
    isSystem?: InputMaybe<Scalars['Boolean']>;
};
/** Updating enumeration */
export declare type BatchMigrationUpdateEnumerationInput = {
    apiId: Scalars['String'];
    newApiId?: InputMaybe<Scalars['String']>;
    displayName?: InputMaybe<Scalars['String']>;
    description?: InputMaybe<Scalars['String']>;
    valuesToCreate?: InputMaybe<Array<BatchMigrationCreateEnumerationValueInput>>;
    valuesToUpdate?: InputMaybe<Array<BatchMigrationUpdateEnumerationValueInput>>;
    valuesToDelete?: InputMaybe<Array<Scalars['String']>>;
    isSystem?: InputMaybe<Scalars['Boolean']>;
};
/** enumeration value */
export declare type BatchMigrationCreateEnumerationValueInput = {
    apiId: Scalars['String'];
    displayName: Scalars['String'];
};
/** update enumeration value */
export declare type BatchMigrationUpdateEnumerationValueInput = {
    apiId: Scalars['String'];
    newApiId?: InputMaybe<Scalars['String']>;
    displayName?: InputMaybe<Scalars['String']>;
};
/** Creating locale */
export declare type BatchMigrationCreateLocaleInput = {
    apiId: Scalars['String'];
    displayName: Scalars['String'];
    description?: InputMaybe<Scalars['String']>;
};
/** Updating locale */
export declare type BatchMigrationUpdateLocaleInput = {
    apiId: Scalars['String'];
    newApiId?: InputMaybe<Scalars['String']>;
    isDefault?: InputMaybe<Scalars['Boolean']>;
    displayName?: InputMaybe<Scalars['String']>;
    description?: InputMaybe<Scalars['String']>;
};
/** Deleting locale */
export declare type BatchMigrationDeleteLocaleInput = {
    apiId: Scalars['String'];
    force?: InputMaybe<Scalars['Boolean']>;
};
export declare type BatchMigrationCreateGraphQlRemoteSourceInput = {
    displayName: Scalars['String'];
    description?: InputMaybe<Scalars['String']>;
    /** Unique prefix that will be prepended to all of the remote types. This value cannot be changed! */
    prefix: Scalars['String'];
    url: Scalars['String'];
    headers?: InputMaybe<Scalars['JSON']>;
    /**
     * Specific URL that will be used for introspection if the introspection is available on another url than the regular url.
     * Can be ignored if the introspection url is the same as the url of the remote source.
     */
    introspectionUrl?: InputMaybe<Scalars['String']>;
    /** HTTP method that will be used for introspection */
    introspectionMethod: GraphQlRemoteSourceIntrospectionMethod;
    /** HTTP headers that will be used for introspection */
    introspectionHeaders?: InputMaybe<Scalars['JSON']>;
    /** Custom GraphQL input types that can be used as arguments in remote fields that belong to this remoteSource */
    remoteTypeDefinitions?: InputMaybe<BatchMigrationCreateRemoteTypeDefinitionInput>;
    debugEnabled?: InputMaybe<Scalars['Boolean']>;
};
export declare type BatchMigrationUpdateGraphQlRemoteSourceInput = {
    prefix: Scalars['String'];
    displayName?: InputMaybe<Scalars['String']>;
    description?: InputMaybe<Scalars['String']>;
    url?: InputMaybe<Scalars['String']>;
    headers?: InputMaybe<Scalars['JSON']>;
    introspectionUrl?: InputMaybe<Scalars['String']>;
    introspectionMethod?: InputMaybe<GraphQlRemoteSourceIntrospectionMethod>;
    introspectionHeaders?: InputMaybe<Scalars['JSON']>;
    remoteTypeDefinitionsToUpsert?: InputMaybe<BatchMigrationUpsertRemoteTypeDefinitionsInput>;
    debugEnabled?: InputMaybe<Scalars['Boolean']>;
};
export declare type BatchMigrationRefreshGraphQlRemoteSourceSchemaInput = {
    prefix: Scalars['String'];
};
export declare type BatchMigrationCreateRestRemoteSourceInput = {
    displayName: Scalars['String'];
    description?: InputMaybe<Scalars['String']>;
    /** Unique prefix that will be prepended to all of the remote types. This value cannot be changed! */
    prefix: Scalars['String'];
    url: Scalars['String'];
    headers?: InputMaybe<Scalars['JSON']>;
    /** Remote type definitions that the remote source supports or input types that can be used by any remote field of this remote source */
    remoteTypeDefinitions?: InputMaybe<BatchMigrationCreateRemoteTypeDefinitionInput>;
    debugEnabled?: InputMaybe<Scalars['Boolean']>;
};
export declare type BatchMigrationUpdateRestRemoteSourceInput = {
    prefix: Scalars['String'];
    displayName: Scalars['String'];
    description?: InputMaybe<Scalars['String']>;
    url?: InputMaybe<Scalars['String']>;
    headers?: InputMaybe<Scalars['JSON']>;
    remoteTypeDefinitionsToUpsert?: InputMaybe<BatchMigrationUpsertRemoteTypeDefinitionsInput>;
    debugEnabled?: InputMaybe<Scalars['Boolean']>;
};
export declare type BatchMigrationCreateRemoteTypeDefinitionInput = {
    sdl: Scalars['String'];
};
export declare type BatchMigrationDeleteRemoteSourceInput = {
    prefix: Scalars['String'];
};
export declare type BatchMigrationUpdateAppInstallationInput = {
    /** App Installation config, the object passed will be merged with the existing config */
    config?: InputMaybe<Scalars['JSON']>;
    /** App Installation status */
    status?: InputMaybe<AppInstallationStatus>;
};
/** Creating a custom sidebar element with app element */
export declare type BatchMigrationCreateCustomSidebarElementInput = {
    /** Api Id of the model associated with the custom sidebar element */
    modelApiId: Scalars['String'];
    /** Display name for the sidebar element */
    displayName: Scalars['String'];
    /** Description name for the sidebar element */
    description?: InputMaybe<Scalars['String']>;
    /** Json metadata associated with the sidebar element */
    config?: InputMaybe<Scalars['JSON']>;
    /** Api Id of the App element to create custom sidebar element with */
    appElementApiId: Scalars['String'];
    /** Api Id of the App */
    appApiId: Scalars['String'];
};
/** Deleting a custom sidebar element created by app element */
export declare type BatchMigrationDeleteCustomSidebarElementInput = {
    /** Api Id of the App */
    appApiId: Scalars['String'];
    /** Api Id of the App element associated with the custom sidebar element */
    appElementApiId: Scalars['String'];
    /** Api Id of the model associated with the custom sidebar element */
    modelApiId: Scalars['String'];
};
export declare type BatchMigrationCreateWebhookInput = {
    name: Scalars['String'];
    description?: InputMaybe<Scalars['String']>;
    url: Scalars['String'];
    method?: InputMaybe<WebhookMethod>;
    headers?: InputMaybe<Scalars['JSON']>;
    isActive: Scalars['Boolean'];
    includePayload: Scalars['Boolean'];
    /**
     * Pass an empty array for all existing models.
     * This will also setup the webhook for models
     * created in the future
     */
    models: Array<Scalars['ID']>;
    /**
     * Pass an empty array for all existing stages.
     * This will also setup the webhook for stages
     * created in the future
     */
    stages: Array<Scalars['ID']>;
    triggerType: WebhookTriggerType;
    triggerActions: Array<WebhookTriggerAction>;
    secretKey?: InputMaybe<Scalars['String']>;
    triggerSources?: InputMaybe<Array<WebhookTriggerSource>>;
    isSystem?: InputMaybe<Scalars['Boolean']>;
};
export declare type BatchMigrationUpdateWebhookInput = {
    webhookId: Scalars['ID'];
    name?: InputMaybe<Scalars['String']>;
    description?: InputMaybe<Scalars['String']>;
    headers?: InputMaybe<Scalars['JSON']>;
    url?: InputMaybe<Scalars['String']>;
    method?: InputMaybe<WebhookMethod>;
    isActive?: InputMaybe<Scalars['Boolean']>;
    includePayload?: InputMaybe<Scalars['Boolean']>;
    stages?: InputMaybe<Array<Scalars['ID']>>;
    models?: InputMaybe<Array<Scalars['ID']>>;
    triggerType?: InputMaybe<WebhookTriggerType>;
    triggerActions?: InputMaybe<Array<WebhookTriggerAction>>;
    secretKey?: InputMaybe<Scalars['String']>;
    triggerSources?: InputMaybe<Array<WebhookTriggerSource>>;
    isSystem?: InputMaybe<Scalars['Boolean']>;
};
export declare type BatchMigrationDeleteWebhookInput = {
    webhookId: Scalars['ID'];
};
export declare type BatchMigrationChangeInput = {
    /** creates a new model */
    createModel?: InputMaybe<BatchMigrationCreateModelInput>;
    updateModel?: InputMaybe<BatchMigrationUpdateModelInput>;
    deleteModel?: InputMaybe<BatchMigrationDeleteModelInput>;
    createComponent?: InputMaybe<BatchMigrationCreateComponentInput>;
    updateComponent?: InputMaybe<BatchMigrationUpdateComponentInput>;
    deleteComponent?: InputMaybe<BatchMigrationDeleteComponentInput>;
    createSimpleField?: InputMaybe<BatchMigrationCreateSimpleFieldInput>;
    updateSimpleField?: InputMaybe<BatchMigrationUpdateSimpleFieldInput>;
    createRemoteField?: InputMaybe<BatchMigrationCreateRemoteFieldInput>;
    updateRemoteField?: InputMaybe<BatchMigrationUpdateRemoteFieldInput>;
    createRelationalField?: InputMaybe<BatchMigrationCreateRelationalFieldInput>;
    updateRelationalField?: InputMaybe<BatchMigrationUpdateRelationalFieldInput>;
    createUnionField?: InputMaybe<BatchMigrationCreateUnionFieldInput>;
    updateUnionField?: InputMaybe<BatchMigrationUpdateUnionFieldInput>;
    createComponentField?: InputMaybe<BatchMigrationCreateComponentFieldInput>;
    updateComponentField?: InputMaybe<BatchMigrationUpdateComponentFieldInput>;
    createComponentUnionField?: InputMaybe<BatchMigrationCreateComponentUnionFieldInput>;
    updateComponentUnionField?: InputMaybe<BatchMigrationUpdateComponentUnionFieldInput>;
    createEnumerableField?: InputMaybe<BatchMigrationCreateEnumerableFieldInput>;
    updateEnumerableField?: InputMaybe<BatchMigrationUpdateEnumerableFieldInput>;
    deleteField?: InputMaybe<BatchMigrationDeleteFieldInput>;
    createCustomSidebarElement?: InputMaybe<BatchMigrationCreateCustomSidebarElementInput>;
    deleteCustomSidebarElement?: InputMaybe<BatchMigrationDeleteCustomSidebarElementInput>;
    createEnumeration?: InputMaybe<BatchMigrationCreateEnumerationInput>;
    updateEnumeration?: InputMaybe<BatchMigrationUpdateEnumerationInput>;
    deleteEnumeration?: InputMaybe<BatchMigrationDeleteEnumerationInput>;
    createStage?: InputMaybe<BatchMigrationCreateStageInput>;
    deleteStage?: InputMaybe<BatchMigrationDeleteStageInput>;
    updateStage?: InputMaybe<BatchMigrationUpdateStageInput>;
    createLocale?: InputMaybe<BatchMigrationCreateLocaleInput>;
    deleteLocale?: InputMaybe<BatchMigrationDeleteLocaleInput>;
    updateLocale?: InputMaybe<BatchMigrationUpdateLocaleInput>;
    createGraphQLRemoteSource?: InputMaybe<BatchMigrationCreateGraphQlRemoteSourceInput>;
    updateGraphQLRemoteSource?: InputMaybe<BatchMigrationUpdateGraphQlRemoteSourceInput>;
    refreshGraphQLRemoteSourceSchema?: InputMaybe<BatchMigrationRefreshGraphQlRemoteSourceSchemaInput>;
    createRESTRemoteSource?: InputMaybe<BatchMigrationCreateRestRemoteSourceInput>;
    updateRESTRemoteSource?: InputMaybe<BatchMigrationUpdateRestRemoteSourceInput>;
    deleteRemoteSource?: InputMaybe<BatchMigrationDeleteRemoteSourceInput>;
    /** updates config and status for an AppInstallation, only valid for App Token bearer */
    updateAppInstallation?: InputMaybe<BatchMigrationUpdateAppInstallationInput>;
    /** creates a webhook */
    createWebhook?: InputMaybe<BatchMigrationCreateWebhookInput>;
    /** updates a webhook */
    updateWebhook?: InputMaybe<BatchMigrationUpdateWebhookInput>;
    /** deletes a webhook */
    deleteWebhook?: InputMaybe<BatchMigrationDeleteWebhookInput>;
};
export declare type DiffEnvironmentPayload = {
    __typename?: 'DiffEnvironmentPayload';
    changes: Array<Scalars['JSON']>;
};
export declare type BatchMigrationInput = {
    environmentId: Scalars['ID'];
    name?: InputMaybe<Scalars['String']>;
    changes: Array<BatchMigrationChangeInput>;
};
export declare type BatchMigrationUpsertRemoteTypeDefinitionsInput = {
    remoteTypeDefinitionsToCreate?: InputMaybe<Array<BatchMigrationUpsertRemoteTypeDefinitionToCreateInput>>;
    remoteTypeDefinitionsToDelete?: InputMaybe<Array<BatchMigrationUpsertRemoteTypeDefinitionToDeleteInput>>;
    remoteTypeDefinitionsToUpdate?: InputMaybe<Array<BatchMigrationUpsertRemoteTypeDefinitionToUpdateInput>>;
};
export declare type BatchMigrationUpsertRemoteTypeDefinitionToCreateInput = {
    sdl: Scalars['String'];
};
export declare type BatchMigrationUpsertRemoteTypeDefinitionToDeleteInput = {
    apiId: Scalars['String'];
};
export declare type BatchMigrationUpsertRemoteTypeDefinitionToUpdateInput = {
    apiId: Scalars['String'];
    sdl?: InputMaybe<Scalars['String']>;
};
export declare enum RemoteSourceType {
    Graphql = "GRAPHQL",
    Rest = "REST"
}
export declare type Mutation = {
    __typename?: 'Mutation';
    submitBatchChanges: AsyncOperationPayload;
};
export declare type MutationSubmitBatchChangesArgs = {
    data: BatchMigrationInput;
};
export declare enum MigrationOperationType {
    CreateProjectFromTemplate = "CREATE_PROJECT_FROM_TEMPLATE",
    CreateEnvironment = "CREATE_ENVIRONMENT",
    Batch = "BATCH",
    CreateStage = "CREATE_STAGE",
    UpdateStage = "UPDATE_STAGE",
    DeleteStage = "DELETE_STAGE",
    CreateLocale = "CREATE_LOCALE",
    UpdateLocale = "UPDATE_LOCALE",
    DeleteLocale = "DELETE_LOCALE",
    CreateModel = "CREATE_MODEL",
    UpdateModel = "UPDATE_MODEL",
    DeleteModel = "DELETE_MODEL",
    CreateRemoteTypeDefinition = "CREATE_REMOTE_TYPE_DEFINITION",
    UpdateRemoteTypeDefinition = "UPDATE_REMOTE_TYPE_DEFINITION",
    DeleteRemoteTypeDefinition = "DELETE_REMOTE_TYPE_DEFINITION",
    CreateEnumeration = "CREATE_ENUMERATION",
    UpdateEnumeration = "UPDATE_ENUMERATION",
    DeleteEnumeration = "DELETE_ENUMERATION",
    CreateSimpleField = "CREATE_SIMPLE_FIELD",
    CreateEnumerableField = "CREATE_ENUMERABLE_FIELD",
    CreateRelationalField = "CREATE_RELATIONAL_FIELD",
    CreateUnionField = "CREATE_UNION_FIELD",
    CreateRemoteField = "CREATE_REMOTE_FIELD",
    UpdateSimpleField = "UPDATE_SIMPLE_FIELD",
    UpdateEnumerableField = "UPDATE_ENUMERABLE_FIELD",
    UpdateRelationalField = "UPDATE_RELATIONAL_FIELD",
    UpdateUnionField = "UPDATE_UNION_FIELD",
    DeleteField = "DELETE_FIELD"
}
export declare enum NetlifyBuildState {
    Ready = "READY",
    Preparing = "PREPARING",
    Building = "BUILDING",
    Failed = "FAILED"
}
